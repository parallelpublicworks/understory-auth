{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/drupal-oauth.js","../src/auth-context.js","../src/index.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import docCookies from \"mozilla-doc-cookies\";\n\nfunction checkIfDuplicateModification(body){\n  return body.hasOwnProperty('errors') &&\n    body.errors.length === 1 &&\n    body.errors[0].status === \"422\" &&\n    body.errors[0].hasOwnProperty('detail') &&\n    body.errors[0].detail ===\n    \"Entity is not valid: The content has either been modified by another user, or you have already submitted modifications. As a result, your changes cannot be saved.\";\n}\n\nfunction getPath(defaultEndpoint, endpointEnvVar){\n  let endpoint = defaultEndpoint;\n  if(process.env[endpointEnvVar]){\n    endpoint = process.env[endpointEnvVar];\n  }\n  return endpoint.replace(/\\/$/, \"\").replace(/^\\//, \"\"); // strip beginning and end slash\n}\n\nexport class DrupalOAuth{\n  constructor(args){\n    if(args.baseUrl){\n      this.baseUrl = args.baseUrl;\n    }\n    if(args.clientId){\n      this.clientId = args.clientId;\n    }\n    this.token = typeof window !== `undefined` && docCookies.hasItem('refresh_token') && docCookies.hasItem('access_token') ? {\n      refresh_token: docCookies.getItem('refresh_token'),\n      access_token: docCookies.getItem('access_token'),\n    } : false;\n    this.isLoggedIn = this.isLoggedIn.bind(this);\n\n  }\n\n  getBaseUrl(){\n    if(!process.env.REACT_APP_ENTITYSYNC_BASE_URL && !this.baseUrl){\n      throw new Error(\"Missing base url for Entity Sync. Please set the REACT_APP_ENTITYSYNC_BASE_URL environment variable or pass in `baseUrl` to the DrupalOAuth object as the base url of your backend, like 'https://www.my-backend.com'\")\n    }\n    if(this.baseUrl){\n      return this.baseUrl;\n    }\n    return process.env.REACT_APP_ENTITYSYNC_BASE_URL.replace(/\\/$/, \"\"); // strip end slash\n  }\n\n  getClientId(){\n    if(!process.env.REACT_APP_ENTITYSYNC_CLIENT_ID && !this.clientId){\n      throw new Error(\"Missing client ID for Entity Sync. Please set the REACT_APP_ENTITYSYNC_CLIENT_ID environment variable or pass in `clientId` to the DrupalOAuth object as the OAuth client_id of your app.\")\n    }\n    if(this.clientId){\n      return this.clientId;\n    }\n    return process.env.REACT_APP_ENTITYSYNC_CLIENT_ID;\n  }\n\n  /**\n   *\n   * @param resp\n   * @returns {Promise<object | boolean>} returns a truthy value if this is a valid response\n   */\n  async verifyResponse(resp){\n    // check match for 2XX status for success\n    if(/2../.test(resp.status.toString())){\n      // Our access token works\n      if(resp.status === 204){\n        //No content returned, don't return any json\n        return true;\n      }\n      return await resp.json();\n    }\n    return false;\n  }\n\n  /**\n   * Fetch data from a Drupal back end. Expects to be called in a locally logged in context (i.e we have some kind of\n   * token). It will try to use the refresh token if it fails via 401 the first time. If it still fails after\n   * refreshing, it will return false, signifying that this user should no longer be logged in.\n   *\n   * @param {string} jsonapiEndpoint An endpoint to retrieve resources using the JSONAPI (https://jsonapi.org/). Includes\n   * everything after the host except the leading slash (ex. `'articles?page[offset]=2'`)\n   * @param {string} method An HTTP verb, mainly meant for `'GET'`, `'POST'`, `'PATCH'` and `'DELETE'`\n   * @param {object|null} body The body of the request, for `'POST'` and `'PATCH'`\n   * @param {object} headers\n   *\n   * @returns {Promise<object | Boolean>} A promise which will return a JSON object of content, true if success with no\n   * content, or false if it failed\n   */\n  async drupalFetch(jsonapiEndpoint, method='GET', body=null, headers=null){\n    if(body && !(body instanceof File)){\n      body = JSON.stringify(body)\n    }\n\n    const base = this.getBaseUrl();\n    const jsonapiBase = getPath('jsonapi', 'REACT_APP_ENTITYSYNC_JSONAPI_BASE');\n    const url = `${base}/${jsonapiBase}/${jsonapiEndpoint}`;\n    const init = {\n      method: method,\n      headers: {\n        'Authorization': `Bearer ${this.token.access_token}`,\n        'Content-Type':  'application/vnd.api+json'\n      },\n    };\n    Object.assign(init.headers, headers);\n    if(body){\n      init.body = body\n    }\n    const resp = await fetch(url, init);\n    const validResponse = await this.verifyResponse(resp);\n    if(validResponse){\n      return validResponse;\n    }\n\n    else if(resp.status === 401 || resp.status === 403){\n      // if we get 401 unauthorized (or apparently a 403, since JSONAPI seems to give us this), its probably because our access token is expired.\n      // refresh and try again with a new token\n      const newToken = await this.refresh();\n      if(newToken) {\n        // Our refresh token is still good, we've got a fresh token\n        init.headers = {\n          'Authorization': `Bearer ${newToken.access_token}`,\n          'Content-Type':  'application/vnd.api+json'\n        };\n        Object.assign(init.headers, headers);\n        const secondResp = await fetch(url, init);\n        // check match for 2XX status for success\n        const validResponse = await this.verifyResponse(secondResp);\n        if(validResponse){\n          return validResponse;\n        }\n        else{\n          /*TODO: Try one more time? We expect to be logged in so either\n           something external happened (and we should try again), the expiration on the token is too short,\n           or we made a bad request.*/\n        }\n      }\n    }\n    else if(resp.status === 422){\n      // if we get a duplicate modification error, just ignore it. our API interactions should be designed to avoid them,\n      // and if any actually do happen, they should be truly duplicate, meaning that the failed one can be safely discarded\n      const body = await resp.json();\n      if(checkIfDuplicateModification(body)){\n        return body;\n      }\n\n    }\n\n    // If everything fails, return false\n    return false;\n  }\n\n  /**\n   * Uses the refresh token stored in the cookie to get a new oauth token.\n   * @returns {Promise<object | Boolean>} A token object with `refresh_token` and `access_token`, or false if no\n   * existing refresh token or login failed (meaning this user is not logged in)\n   */\n  async refresh(){\n    let refreshToken = false;\n    if (typeof window !== `undefined`) {\n      refreshToken = docCookies.getItem('refresh_token');\n    } \n    if(typeof refreshToken !== `undefined` && refreshToken){\n      return await this.authPost('refresh_token', refreshToken);\n    }\n\n    return false\n  }\n\n  /**\n   * Checks local state to see if we have a token. Run refresh\n   * @returns {boolean}\n   */\n  isLoggedIn(){\n    return this.token ? true : false;\n  }\n\n  /**\n   * Authenticates against a Drupal oauth backend. Will set or unset cookie with refresh token on success or failure.\n   *\n   * @param grantType Either `'password'` or `'refresh_token'`\n   * @param authValue The value of the refresh token, if using `refresh_token` grant type\n   * @param FormData object, if you are using the password grant, you should turn your form element into a formData object then pass to authPost. This way you can manipulate the formObject outside of the authPost method.\n   * @returns {Promise<object | Boolean>} A token object with `refresh_token` and `access_token`, or false if login\n   * failed\n   */\n  async authPost(grantType, authValue=null, form=null){\n    const base = this.getBaseUrl();\n    const url = base + '/oauth/token';\n    const formData = form ? form : new FormData();\n    if(authValue){\n      formData.append(grantType, authValue);\n    }\n    formData.append('grant_type', grantType);\n    formData.append('client_id', this.getClientId());\n    const init = {\n      method: 'POST',\n      body: formData,\n    };\n    let resp;\n    try {\n      resp = await fetch(url, init);\n    } catch (e) {\n      console.log(e);\n    }\n    if(resp && resp.status === 200){\n      this.token = await resp.json();\n      if (typeof window !== `undefined`) {\n        // For inherit sessions to iframes, for handling authorization through Drupal OAuth\n        docCookies.setItem('refresh_token', this.token.refresh_token, Infinity, '/; SameSite=None; Secure');\n        docCookies.setItem('access_token', this.token.access_token, Infinity, '/; SameSite=None; Secure');\n      }\n      return this.token;\n    }\n    // else if(resp.status === 500){\n    //   //service unavailable, trying again\n    //   const secondResp = await fetch(url, init);\n    //   if(secondResp.status === 200){\n    //     this.token = await secondResp.json();\n    //     docCookies.setItem('refresh_token', this.token.refresh_token);\n    //     return this.token;\n    //   }\n    // }\n    else{\n      this.removeTokens();\n      return false;\n    }\n  }\n\n  /**\n   *\n   * @param formData\n   * @param grantType\n   * @returns {Promise<{token: Object|Boolean, uid: null}>}\n   */\n  async loginUser(formData, grantType){\n    const initialLoginResponse = await this.authPost(grantType, null, formData);\n    return { token: initialLoginResponse, };\n  }\n\n  async logoutUser(){\n    if (typeof window !== `undefined`) {\n      this.removeTokens();\n      //removes all localstorage for page\n      localStorage.clear();\n      //removes current access tokens/response\n      this.token = false;\n      return !docCookies.hasItem('refresh_token');\n    } else {\n      return true;\n    }\n  }\n\n  removeTokens(){\n    if (typeof window !== `undefined`) {\n      docCookies.removeItem('refresh_token', '/');\n      docCookies.removeItem('access_token', '/');\n    }\n  }\n\n}\n","import React from \"react\";\n\nimport { DrupalOAuth, } from \"./drupal-oauth\";\n\nconst initialState = {};\nexport const AuthContext = React.createContext(initialState);\n\nconst LOGOUT_USER_ACTION_TYPE = \"LOGOUT_USER\";\nfunction logoutUserAction(){\n  return {\n    type: LOGOUT_USER_ACTION_TYPE,\n  }\n}\n\nconst AUTHENTICATE_USER_ACTION_TYPE = \"AUTHENTICATE_USER\";\nfunction authenticateUserAction(){\n  return {\n    type: AUTHENTICATE_USER_ACTION_TYPE,\n  }\n}\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case AUTHENTICATE_USER_ACTION_TYPE:\n      return {\n        ...state,\n        isAuthenticated: true,\n      };\n    case LOGOUT_USER_ACTION_TYPE:\n      return {\n        ...state,\n        isAuthenticated: false,\n      };\n    default:\n      return state;\n  }\n};\n\n/**\n * A listener for the form submit of the login form.\n * @param {[AuthState, React.Dispatch<AuthAction>]} authContext\n * @param ev\n * @returns {Promise<void>}\n */\nexport async function handleLogin(authContext, ev){\n  const [state, dispatch] = authContext;\n  const auth = new DrupalOAuth(state);\n  const formData = new FormData(event.target);\n  const token = await auth.loginUser(formData, 'password');\n  if(token && token.token) {\n    dispatch(authenticateUserAction());\n  }\n  else{\n    //TODO: inform the user that they failed to log in.\n    return false;\n  }\n}\n/**\n * A listener for the form submit of the login form.\n * @param {[AuthState, React.Dispatch<AuthAction>]} authContext\n * @param formData\n * @returns {Promise<void>}\n */\nexport async function submitLogin(authContext, formData){\n  const [state, dispatch] = authContext;\n  const auth = new DrupalOAuth(state);\n  const token = await auth.loginUser(formData, 'authorization_code');\n  if(token && token.token) {\n    dispatch(authenticateUserAction());\n  }\n  else{\n    //TODO: inform the user that they failed to log in.\n    return false;\n  }\n}\n\nexport function handleLogout(authContext){\n  const [state, dispatch] = authContext;\n  const auth = new DrupalOAuth(state);\n  const loggedOut = auth.logoutUser();\n  //updates the state which forces a re render which will force the user off the page\n  if(loggedOut){\n    dispatch(logoutUserAction());\n  }\n  return loggedOut;\n}\n\n/**\n *\n * This function uses the auth service to retrieve authenticated data. It checks if the user is still signed in after\n * the whole affair is over and updates the store if not.\n *\n * This should not be imported directly, as it expects to be in a logged in environment.\n * Let it be passed into your page component by wrapping it with the `UserContext`.\n *\n * @see signInToView\n * @see AuthContextProvider\n *\n * @param authContext Either the dispatch function to the reducer or the whole auth context, as an array with the state as the first element and the dispatch function as the second.\n * @param {string} jsonapi_endpoint An endpoint to retrieve resources using the JSONAPI (https://jsonapi.org/). Includes\n * everything after the host except the leading slash (ex. `'articles?page[offset]=2'`)\n * @param {string} method An HTTP verb, mainly meant for `'GET'`,`'POST'`, `'PATCH'` and `'DELETE'`\n * @param {Object|null} body The body of the request, for `'POST'` and `'PATCH'`\n * @param headers\n *\n * @returns {Promise<object | Boolean>} A promise which will return a JSON object of content or false if it failed\n */\nexport async function fetchAuthenticatedContent(authContext, jsonapi_endpoint, method='GET', body=null, headers=null){\n  let state, dispatch;\n  if(Array.isArray(authContext)){\n    [state, dispatch] = authContext\n  }\n  else{\n    state = {};\n    dispatch = authContext;\n  }\n  const auth = new DrupalOAuth(state);\n  const content = await auth.drupalFetch(jsonapi_endpoint, method, body, headers);\n  if(!content){\n    dispatch(logoutUserAction());\n  }\n  return content;\n}\n\n/**\n * Wrap the context provider so that the consumer receives the functions from the auth service to login and fetch\n * authenticated content. These functions are bound to the store and will dispatch actions to change the\n * `isAuthenticated` state. Also initiates the process of determining if we are logged in on first page load.\n *\n * @param props can pass in clientId and/or baseUrl to this\n * @returns {*} The\n * @constructor\n */\nexport const AuthContextProvider = props => {\n  const auth = new DrupalOAuth(props);\n  const state =  {...initialState, isAuthenticated: auth.isLoggedIn() };\n\n  if(props.clientId){\n    state.clientId = props.clientId;\n  }\n  if(props.baseUrl){\n    state.baseUrl = props.baseUrl;\n  }\n\n  const [authState, dispatch] = React.useReducer(reducer, state);\n  return (\n    <AuthContext.Provider\n      value={ [{\n        ...authState,\n      }, dispatch] }\n    >\n      {props.children}\n    </AuthContext.Provider>\n  );\n};\n\n","import * as AuthContextLib from \"./auth-context\";\n\nexport const AuthContext = AuthContextLib.AuthContext;\nexport const AuthContextProvider = AuthContextLib.AuthContextProvider;\nexport const submitLogin = AuthContextLib.submitLogin;\nexport const handleLogin = AuthContextLib.handleLogin;\nexport const handleLogout = AuthContextLib.handleLogout;\nexport const fetchAuthenticatedContent = AuthContextLib.fetchAuthenticatedContent;\n"],"names":["checkIfDuplicateModification","body","hasOwnProperty","errors","length","status","detail","getPath","defaultEndpoint","endpointEnvVar","endpoint","process","env","replace","DrupalOAuth","args","baseUrl","clientId","token","window","docCookies","hasItem","refresh_token","getItem","access_token","isLoggedIn","bind","getBaseUrl","REACT_APP_ENTITYSYNC_BASE_URL","Error","getClientId","REACT_APP_ENTITYSYNC_CLIENT_ID","verifyResponse","resp","test","toString","json","drupalFetch","jsonapiEndpoint","method","headers","File","JSON","stringify","base","jsonapiBase","url","init","Object","assign","fetch","validResponse","refresh","newToken","secondResp","refreshToken","authPost","grantType","authValue","form","setItem","Infinity","removeTokens","formData","FormData","append","e","console","log","loginUser","initialLoginResponse","logoutUser","localStorage","clear","removeItem","fetchAuthenticatedContent","authContext","jsonapi_endpoint","state","dispatch","Array","isArray","auth","content","logoutUserAction","submitLogin","authenticateUserAction","handleLogin","ev","event","target","initialState","AuthContext","React","createContext","LOGOUT_USER_ACTION_TYPE","type","AUTHENTICATE_USER_ACTION_TYPE","reducer","action","isAuthenticated","handleLogout","loggedOut","AuthContextProvider","props","useReducer","authState","children","AuthContextLib"],"mappings":"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"}